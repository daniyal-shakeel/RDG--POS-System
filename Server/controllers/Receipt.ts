import { Request, Response } from 'express';
import { Receipt } from '../models/Receipt';
import { Customer } from '../models/Customer';
import { Product } from '../models/Product';
import { Invoice } from '../models/Invoice';
import { validateData, ValidationError, receiptSchema, validateMongoId } from '../utils/validation';
import mongoose from 'mongoose';

export const createReceipt = async (req: Request, res: Response) => {
    try {
        // Validate and sanitize input data
        const validatedData = validateData(receiptSchema, req.body);
        
        // Validate MongoDB ObjectIds
        try {
            validateMongoId(validatedData.customer_id);
            validateMongoId(validatedData.sales_rep_id);
            validatedData.items.forEach(item => {
                validateMongoId(item.product_id);
            });
            if (validatedData.invoice_id) {
                validateMongoId(validatedData.invoice_id);
            }
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({
                    message: 'Validation failed',
                    errors: error.errors
                });
            }
            throw error;
        }

        // Verify customer exists
        const customer = await Customer.findById(validatedData.customer_id);
        if (!customer) {
            return res.status(404).json({ 
                message: 'Customer not found',
                errors: [{ field: 'customer_id', message: 'Customer with this ID does not exist' }]
            });
        }

        // Verify all products exist
        const productIds = validatedData.items.map(item => new mongoose.Types.ObjectId(item.product_id));
        const products = await Product.find({ _id: { $in: productIds } });
        
        if (products.length !== validatedData.items.length) {
            const foundIds = products.map(p => p._id.toString());
            const missingIds = validatedData.items
                .filter(item => !foundIds.includes(item.product_id))
                .map(item => item.product_id);
            
            return res.status(404).json({
                message: 'One or more products not found',
                errors: [{ 
                    field: 'items', 
                    message: `Products with IDs ${missingIds.join(', ')} do not exist` 
                }]
            });
        }

        // Verify invoice exists if provided
        if (validatedData.invoice_id) {
            const invoice = await Invoice.findById(validatedData.invoice_id);
            if (!invoice) {
                return res.status(404).json({ 
                    message: 'Invoice not found',
                    errors: [{ field: 'invoice_id', message: 'Invoice with this ID does not exist' }]
                });
            }
        }

        // Prepare receipt data
        const receiptData: any = {
            customer_id: new mongoose.Types.ObjectId(validatedData.customer_id),
            items: validatedData.items.map(item => ({
                product_id: new mongoose.Types.ObjectId(item.product_id),
                quantity: item.quantity,
                unit_price: item.unit_price,
                discount_percentage: item.discount_percentage || 0
            })),
            tax_type: validatedData.tax_type,
            tax_value: validatedData.tax_value,
            discount_type: validatedData.discount_type,
            discount_value: validatedData.discount_value,
            deposit_received: validatedData.deposit_received || 0,
            billing_address: validatedData.billing_address,
            shipping_address: validatedData.shipping_address,
            notes: validatedData.notes || '',
            signature: validatedData.signature,
            sales_rep_id: new mongoose.Types.ObjectId(validatedData.sales_rep_id)
        };

        // Add invoice_id if provided
        if (validatedData.invoice_id) {
            receiptData.invoice_id = new mongoose.Types.ObjectId(validatedData.invoice_id);
        }

        // Create new receipt (reference number and totals will be auto-generated by pre-save hook)
        const newReceipt = new Receipt(receiptData);
        await newReceipt.save();

        // Populate references for response
        await newReceipt.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
        await newReceipt.populate('items.product_id', 'product_name product_code description pricing_inventory');
        await newReceipt.populate('sales_rep_id', 'name email');
        if (newReceipt.invoice_id) {
            await newReceipt.populate('invoice_id', 'invoiceReference status total');
        }

        return res.status(201).json({
            message: 'Receipt created successfully',
            receipt: {
                id: newReceipt._id,
                receiptReference: newReceipt.receiptReference,
                invoice_id: newReceipt.invoice_id,
                customer_id: newReceipt.customer_id,
                items: newReceipt.items,
                subtotal: newReceipt.subtotal,
                tax_type: newReceipt.tax_type,
                tax_value: newReceipt.tax_value,
                discount_type: newReceipt.discount_type,
                discount_value: newReceipt.discount_value,
                total: newReceipt.total,
                deposit_received: newReceipt.deposit_received,
                balance_due: newReceipt.balance_due,
                billing_address: newReceipt.billing_address,
                shipping_address: newReceipt.shipping_address,
                notes: newReceipt.notes,
                signature: newReceipt.signature,
                sales_rep_id: newReceipt.sales_rep_id,
                createdAt: newReceipt.createdAt,
                updatedAt: newReceipt.updatedAt
            }
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error creating receipt', 
            error: errorMessage
        });
    }
}

export const getReceipts = async (_req: Request, res: Response) => {
    try {
        const receipts = await Receipt.find()
            .populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress')
            .populate('items.product_id', 'product_name product_code description pricing_inventory')
            .populate('sales_rep_id', 'name email')
            .populate('invoice_id', 'invoiceReference status total')
            .sort({ createdAt: -1 }); // Sort by newest first
        
        return res.status(200).json({ 
            message: 'Receipts fetched successfully', 
            receipts,
            length: receipts.length 
        });
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error fetching receipts', 
            error: errorMessage 
        });
    }
}

export const getReceiptById = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ 
                    message: 'Invalid receipt ID',
                    errors: [{ field: 'id', message: error.errors[0].message }]
                });
            }
            throw error;
        }
        
        // Find receipt and populate related data
        const receipt = await Receipt.findById(id)
            .populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress')
            .populate('items.product_id', 'product_name product_code description pricing_inventory')
            .populate('sales_rep_id', 'name email')
            .populate('invoice_id', 'invoiceReference status total');
        
        if (!receipt) {
            return res.status(404).json({ 
                message: 'Receipt not found',
                errors: [{ field: 'id', message: 'Receipt with this ID does not exist' }]
            });
        }
        
        return res.status(200).json({ 
            message: 'Receipt fetched successfully', 
            receipt 
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error fetching receipt', 
            error: errorMessage 
        });
    }
}

export const updateReceipt = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ 
                    message: 'Invalid receipt ID',
                    errors: [{ field: 'id', message: error.errors[0].message }]
                });
            }
            throw error;
        }

        // Validate and sanitize input data
        const validatedData = validateData(receiptSchema, req.body);
        
        // Validate MongoDB ObjectIds in the data
        try {
            validateMongoId(validatedData.customer_id);
            validateMongoId(validatedData.sales_rep_id);
            validatedData.items.forEach(item => {
                validateMongoId(item.product_id);
            });
            if (validatedData.invoice_id) {
                validateMongoId(validatedData.invoice_id);
            }
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({
                    message: 'Validation failed',
                    errors: error.errors
                });
            }
            throw error;
        }

        // Find receipt
        const receipt = await Receipt.findById(id);
        if (!receipt) {
            return res.status(404).json({ 
                message: 'Receipt not found',
                errors: [{ field: 'id', message: 'Receipt with this ID does not exist' }]
            });
        }

        // Verify customer exists
        const customer = await Customer.findById(validatedData.customer_id);
        if (!customer) {
            return res.status(404).json({ 
                message: 'Customer not found',
                errors: [{ field: 'customer_id', message: 'Customer with this ID does not exist' }]
            });
        }

        // Verify all products exist
        const productIds = validatedData.items.map(item => new mongoose.Types.ObjectId(item.product_id));
        const products = await Product.find({ _id: { $in: productIds } });
        
        if (products.length !== validatedData.items.length) {
            const foundIds = products.map(p => p._id.toString());
            const missingIds = validatedData.items
                .filter(item => !foundIds.includes(item.product_id))
                .map(item => item.product_id);
            
            return res.status(404).json({
                message: 'One or more products not found',
                errors: [{ 
                    field: 'items', 
                    message: `Products with IDs ${missingIds.join(', ')} do not exist` 
                }]
            });
        }

        // Verify invoice exists if provided
        if (validatedData.invoice_id) {
            const invoice = await Invoice.findById(validatedData.invoice_id);
            if (!invoice) {
                return res.status(404).json({ 
                    message: 'Invoice not found',
                    errors: [{ field: 'invoice_id', message: 'Invoice with this ID does not exist' }]
                });
            }
        }

        // Update receipt fields
        receipt.customer_id = new mongoose.Types.ObjectId(validatedData.customer_id);
        receipt.items = validatedData.items.map(item => ({
            product_id: new mongoose.Types.ObjectId(item.product_id),
            quantity: item.quantity,
            unit_price: item.unit_price,
            discount_percentage: item.discount_percentage || 0
        }));
        receipt.tax_type = validatedData.tax_type;
        receipt.tax_value = validatedData.tax_value;
        receipt.discount_type = validatedData.discount_type;
        receipt.discount_value = validatedData.discount_value;
        receipt.deposit_received = validatedData.deposit_received || 0;
        receipt.billing_address = validatedData.billing_address;
        receipt.shipping_address = validatedData.shipping_address;
        receipt.notes = validatedData.notes || '';
        receipt.signature = validatedData.signature;
        receipt.sales_rep_id = new mongoose.Types.ObjectId(validatedData.sales_rep_id);
        
        if (validatedData.invoice_id) {
            receipt.invoice_id = new mongoose.Types.ObjectId(validatedData.invoice_id);
        } else {
            receipt.invoice_id = undefined;
        }

        // Save receipt (totals will be recalculated by pre-save hook)
        await receipt.save();

        // Populate references for response
        await receipt.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
        await receipt.populate('items.product_id', 'product_name product_code description pricing_inventory');
        await receipt.populate('sales_rep_id', 'name email');
        if (receipt.invoice_id) {
            await receipt.populate('invoice_id', 'invoiceReference status total');
        }

        return res.status(200).json({
            message: 'Receipt updated successfully',
            receipt: {
                id: receipt._id,
                receiptReference: receipt.receiptReference,
                invoice_id: receipt.invoice_id,
                customer_id: receipt.customer_id,
                items: receipt.items,
                subtotal: receipt.subtotal,
                tax_type: receipt.tax_type,
                tax_value: receipt.tax_value,
                discount_type: receipt.discount_type,
                discount_value: receipt.discount_value,
                total: receipt.total,
                deposit_received: receipt.deposit_received,
                balance_due: receipt.balance_due,
                billing_address: receipt.billing_address,
                shipping_address: receipt.shipping_address,
                notes: receipt.notes,
                signature: receipt.signature,
                sales_rep_id: receipt.sales_rep_id,
                createdAt: receipt.createdAt,
                updatedAt: receipt.updatedAt
            }
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error updating receipt', 
            error: errorMessage
        });
    }
}

export const deleteReceipt = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ 
                    message: 'Invalid receipt ID',
                    errors: [{ field: 'id', message: error.errors[0].message }]
                });
            }
            throw error;
        }
        
        // Check if receipt exists
        const receipt = await Receipt.findById(id);
        if (!receipt) {
            return res.status(404).json({ 
                message: 'Receipt not found',
                errors: [{ field: 'id', message: 'Receipt with this ID does not exist' }]
            });
        }
        
        // Delete receipt
        await receipt.deleteOne();
        
        return res.status(200).json({ 
            message: 'Receipt deleted successfully' 
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error deleting receipt', 
            error: errorMessage
        });
    }
}

import { Request, Response } from 'express';
import { Estimate } from '../models/Estimates';
import { Customer } from '../models/Customer';
import { Product } from '../models/Product';
import { validateData, ValidationError, estimateSchema, validateMongoId } from '../utils/validation';
import mongoose from 'mongoose';

export const createEstimate = async (req: Request, res: Response) => {
    try {
        // Validate and sanitize input data
        const validatedData = validateData(estimateSchema, req.body);
        
        // Validate MongoDB ObjectIds
        try {
            validateMongoId(validatedData.customer_id);
            validateMongoId(validatedData.sales_rep_id);
            validatedData.items.forEach(item => {
                validateMongoId(item.product_id);
            });
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({
                    message: 'Validation failed',
                    errors: error.errors
                });
            }
            throw error;
        }

        // Verify customer exists
        const customer = await Customer.findById(validatedData.customer_id);
        if (!customer) {
            return res.status(404).json({ 
                message: 'Customer not found',
                errors: [{ field: 'customer_id', message: 'Customer with this ID does not exist' }]
            });
        }

        // Verify all products exist
        const productIds = validatedData.items.map(item => new mongoose.Types.ObjectId(item.product_id));
        const products = await Product.find({ _id: { $in: productIds } });
        
        if (products.length !== validatedData.items.length) {
            const foundIds = products.map(p => p._id.toString());
            const missingIds = validatedData.items
                .filter(item => !foundIds.includes(item.product_id))
                .map(item => item.product_id);
            
            return res.status(404).json({
                message: 'One or more products not found',
                errors: [{ 
                    field: 'items', 
                    message: `Products with IDs ${missingIds.join(', ')} do not exist` 
                }]
            });
        }

        // Validate valid_until date is in the future
        const validUntilDate = new Date(validatedData.valid_until);
        const now = new Date();
        if (validUntilDate <= now) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: [{ 
                    field: 'valid_until', 
                    message: 'Valid until date must be in the future' 
                }]
            });
        }

        // Prepare estimate data
        const estimateData = {
            customer_id: new mongoose.Types.ObjectId(validatedData.customer_id),
            items: validatedData.items.map(item => ({
                product_id: new mongoose.Types.ObjectId(item.product_id),
                quantity: item.quantity,
                unit_price: item.unit_price
            })),
            tax_type: validatedData.tax_type,
            tax_value: validatedData.tax_value,
            discount_type: validatedData.discount_type,
            discount_value: validatedData.discount_value,
            valid_until: validUntilDate,
            notes: validatedData.notes || '',
            sales_rep_id: new mongoose.Types.ObjectId(validatedData.sales_rep_id),
            status: 'Draft' as const,
            balance: 'N/A'
        };

        // Create new estimate (reference number and totals will be auto-generated by pre-save hook)
        const newEstimate = new Estimate(estimateData);
        await newEstimate.save();

        // Populate references for response
        await newEstimate.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
        await newEstimate.populate('items.product_id', 'productName productCode productDescription productPrice');

        return res.status(201).json({
            message: 'Estimate created successfully',
            estimate: {
                id: newEstimate._id,
                estimateReference: newEstimate.estimateReference,
                customer_id: newEstimate.customer_id,
                items: newEstimate.items,
                subtotal: newEstimate.subtotal,
                tax_type: newEstimate.tax_type,
                tax_value: newEstimate.tax_value,
                discount_type: newEstimate.discount_type,
                discount_value: newEstimate.discount_value,
                total: newEstimate.total,
                balance: newEstimate.balance,
                status: newEstimate.status,
                valid_until: newEstimate.valid_until,
                notes: newEstimate.notes,
                sales_rep_id: newEstimate.sales_rep_id,
                createdAt: newEstimate.createdAt,
                updatedAt: newEstimate.updatedAt
            }
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error creating estimate', 
            error: errorMessage
        });
    }
}

export const deleteEstimate = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ message: error.errors[0].message });
            }
            throw error;
        }
        
        // Check if estimate exists
        const estimate = await Estimate.findById(id);
        if (!estimate) {
            return res.status(404).json({ message: 'Estimate not found' });
        }
        
        // Delete estimate
        await estimate.deleteOne();
        return res.status(200).json({ message: 'Estimate deleted successfully' });
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ message: 'Error deleting estimate', error: errorMessage });
    }
}

export const updateEstimate = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ message: error.errors[0].message });
            }
            throw error;
        }
        
        // Validate update data
        const validatedData = validateData(estimateSchema, req.body);
        
        // Check if estimate exists
        const estimate = await Estimate.findById(id);
        if (!estimate) {
            return res.status(404).json({ message: 'Estimate not found' });
        }
        
        // Update estimate
        estimate.set({
            ...validatedData,
            customer_id: new mongoose.Types.ObjectId(validatedData.customer_id),
            items: validatedData.items.map(item => ({
                product_id: new mongoose.Types.ObjectId(item.product_id),
                quantity: item.quantity,
                unit_price: item.unit_price
            })),
            sales_rep_id: new mongoose.Types.ObjectId(validatedData.sales_rep_id),
            valid_until: new Date(validatedData.valid_until)
        });
        
        await estimate.save();
        
        return res.status(200).json({ message: 'Estimate updated successfully', estimate });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ message: 'Error updating estimate', error: errorMessage });
    }
}

export const getEstimate = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        if (id) {
            // Get single estimate
            try {
                validateMongoId(id);
            } catch (error) {
                if (error instanceof ValidationError) {
                    return res.status(400).json({ message: error.errors[0].message });
                }
                throw error;
            }
            
            const estimate = await Estimate.findById(id)
                .populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress')
                .populate('items.product_id', 'productName productCode productDescription productPrice');
            
            if (!estimate) {
                return res.status(404).json({ message: 'Estimate not found' });
            }
            
            return res.status(200).json({ message: 'Estimate fetched successfully', estimate });
        } else {
            // Get all estimates
            const estimates = await Estimate.find()
                .populate('customer_id', 'customerName customerEmail')
                .populate('items.product_id', 'productName productCode')
                .sort({ createdAt: -1 })
                .limit(50);
            
            return res.status(200).json({ 
                message: 'Estimates fetched successfully', 
                estimates,
                count: estimates.length 
            });
        }
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ message: 'Error fetching estimate(s)', error: errorMessage });
    }
}

import { Request, Response } from 'express';
import { Estimate } from '../models/Estimates';
import { Invoice } from '../models/Invoice';
import { Customer } from '../models/Customer';
import { Product } from '../models/Product';
import { validateData, ValidationError, estimateSchema, estimateStatusSchema, validateMongoId } from '../utils/validation';
import mongoose from 'mongoose';

export const createEstimate = async (req: Request, res: Response) => {
    try {
        // Validate and sanitize input data
        const validatedData = validateData(estimateSchema, req.body);
        
        // Validate MongoDB ObjectIds
        try {
            validateMongoId(validatedData.customer_id);
            validateMongoId(validatedData.sales_rep_id);
            validatedData.items.forEach(item => {
                validateMongoId(item.product_id);
            });
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({
                    message: 'Validation failed',
                    errors: error.errors
                });
            }
            throw error;
        }

        // Verify customer exists
        const customer = await Customer.findById(validatedData.customer_id);
        if (!customer) {
            return res.status(404).json({ 
                message: 'Customer not found',
                errors: [{ field: 'customer_id', message: 'Customer with this ID does not exist' }]
            });
        }

        // Verify all products exist
        const productIds = validatedData.items.map(item => new mongoose.Types.ObjectId(item.product_id));
        const products = await Product.find({ _id: { $in: productIds } });
        
        if (products.length !== validatedData.items.length) {
            const foundIds = products.map(p => p._id.toString());
            const missingIds = validatedData.items
                .filter(item => !foundIds.includes(item.product_id))
                .map(item => item.product_id);
            
            return res.status(404).json({
                message: 'One or more products not found',
                errors: [{ 
                    field: 'items', 
                    message: `Products with IDs ${missingIds.join(', ')} do not exist` 
                }]
            });
        }

        // Validate valid_until date is in the future
        const validUntilDate = new Date(validatedData.valid_until);
        const now = new Date();
        if (validUntilDate <= now) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: [{ 
                    field: 'valid_until', 
                    message: 'Valid until date must be in the future' 
                }]
            });
        }

        // Prepare estimate data
        const estimateData = {
            customer_id: new mongoose.Types.ObjectId(validatedData.customer_id),
            items: validatedData.items.map(item => ({
                product_id: new mongoose.Types.ObjectId(item.product_id),
                quantity: item.quantity,
                unit_price: item.unit_price
            })),
            tax_type: validatedData.tax_type,
            tax_value: validatedData.tax_value,
            discount_type: validatedData.discount_type,
            discount_value: validatedData.discount_value,
            valid_until: validUntilDate,
            notes: validatedData.notes || '',
            sales_rep_id: new mongoose.Types.ObjectId(validatedData.sales_rep_id),
            status: 'Draft' as const,
            balance: 'N/A'
        };

        // Create new estimate (reference number and totals will be auto-generated by pre-save hook)
        const newEstimate = new Estimate(estimateData);
        await newEstimate.save();

        // Populate references for response
        await newEstimate.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
        await newEstimate.populate('items.product_id', 'product_name product_code description pricing_inventory');

        return res.status(201).json({
            message: 'Estimate created successfully',
            estimate: {
                id: newEstimate._id,
                estimateReference: newEstimate.estimateReference,
                customer_id: newEstimate.customer_id,
                items: newEstimate.items,
                subtotal: newEstimate.subtotal,
                tax_type: newEstimate.tax_type,
                tax_value: newEstimate.tax_value,
                discount_type: newEstimate.discount_type,
                discount_value: newEstimate.discount_value,
                total: newEstimate.total,
                balance: newEstimate.balance,
                status: newEstimate.status,
                valid_until: newEstimate.valid_until,
                notes: newEstimate.notes,
                sales_rep_id: newEstimate.sales_rep_id,
                createdAt: newEstimate.createdAt,
                updatedAt: newEstimate.updatedAt
            }
        });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error creating estimate', 
            error: errorMessage
        });
    }
}

export const deleteEstimate = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ message: error.errors[0].message });
            }
            throw error;
        }
        
        // Check if estimate exists
        const estimate = await Estimate.findById(id);
        if (!estimate) {
            return res.status(404).json({ message: 'Estimate not found' });
        }
        
        // Delete estimate
        await estimate.deleteOne();
        return res.status(200).json({ message: 'Estimate deleted successfully' });
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ message: 'Error deleting estimate', error: errorMessage });
    }
}

export const updateEstimate = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ message: error.errors[0].message });
            }
            throw error;
        }
        
        // Validate update data
        const validatedData = validateData(estimateSchema, req.body);
        
        // Check if estimate exists
        const estimate = await Estimate.findById(id);
        if (!estimate) {
            return res.status(404).json({ message: 'Estimate not found' });
        }
        
        // Update estimate
        estimate.set({
            ...validatedData,
            customer_id: new mongoose.Types.ObjectId(validatedData.customer_id),
            items: validatedData.items.map(item => ({
                product_id: new mongoose.Types.ObjectId(item.product_id),
                quantity: item.quantity,
                unit_price: item.unit_price
            })),
            sales_rep_id: new mongoose.Types.ObjectId(validatedData.sales_rep_id),
            valid_until: new Date(validatedData.valid_until)
        });
        
        await estimate.save();
        
        return res.status(200).json({ message: 'Estimate updated successfully', estimate });
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ message: 'Error updating estimate', error: errorMessage });
    }
}

export const getEstimate = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        if (id) {
            // Get single estimate
            try {
                validateMongoId(id);
            } catch (error) {
                if (error instanceof ValidationError) {
                    return res.status(400).json({ message: error.errors[0].message });
                }
                throw error;
            }
            
            const estimate = await Estimate.findById(id)
                .populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress')
                .populate('items.product_id', 'product_name product_code description pricing_inventory');
            
            if (!estimate) {
                return res.status(404).json({ message: 'Estimate not found' });
            }
            
            return res.status(200).json({ message: 'Estimate fetched successfully', estimate });
        } else {
            // Get all estimates
            const estimates = await Estimate.find()
                .populate('customer_id', 'customerName customerEmail')
                .populate('items.product_id', 'product_name product_code')
                .sort({ createdAt: -1 })
                .limit(50);
            
            return res.status(200).json({ 
                message: 'Estimates fetched successfully', 
                estimates,
                count: estimates.length 
            });
        }
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ message: 'Error fetching estimate(s)', error: errorMessage });
    }
}

/**
 * Valid status transitions map
 * Key: current status, Value: array of allowed next statuses
 */
const validStatusTransitions: Record<string, string[]> = {
    'Draft': ['Pending', 'Accepted', 'Rejected', 'Expired'],
    'Pending': ['Accepted', 'Rejected', 'Expired'],
    'Accepted': [], // Final status - no transitions allowed
    'Rejected': [], // Final status - no transitions allowed
    'Expired': [] // Final status - no transitions allowed
};

/**
 * Check if status transition is valid
 */
const isValidStatusTransition = (currentStatus: string, newStatus: string): boolean => {
    // Same status is always valid (idempotent)
    if (currentStatus === newStatus) {
        return true;
    }
    
    // Check if transition is allowed
    const allowedTransitions = validStatusTransitions[currentStatus] || [];
    return allowedTransitions.includes(newStatus);
};

/**
 * Check if estimate has expired based on valid_until date
 */
const isEstimateExpired = (validUntil: Date): boolean => {
    const now = new Date();
    return validUntil < now;
};

export const updateEstimateStatus = async (req: Request, res: Response) => {
    try {
        const { id } = req.params;
        
        // Validate MongoDB ObjectId format
        try {
            validateMongoId(id);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({ 
                    message: 'Invalid estimate ID',
                    errors: [{ field: 'id', message: error.errors[0].message }]
                });
            }
            throw error;
        }

        // Validate status update data
        let validatedData;
        try {
            validatedData = validateData(estimateStatusSchema, req.body);
        } catch (error) {
            if (error instanceof ValidationError) {
                return res.status(400).json({
                    message: 'Validation failed',
                    errors: error.errors
                });
            }
            throw error;
        }

        // Find estimate
        const estimate = await Estimate.findById(id);
        if (!estimate) {
            return res.status(404).json({ 
                message: 'Estimate not found',
                errors: [{ field: 'id', message: 'Estimate with this ID does not exist' }]
            });
        }

        const currentStatus = estimate.status;
        const newStatus = validatedData.status;

        // Check if status is already the same (idempotent operation)
        if (currentStatus === newStatus) {
            // Populate for response
            await estimate.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
            await estimate.populate('items.product_id', 'product_name product_code description pricing_inventory');
            
            return res.status(200).json({
                message: 'Estimate status is already set to this value',
                estimate: {
                    id: estimate._id,
                    estimateReference: estimate.estimateReference,
                    status: estimate.status,
                    previousStatus: currentStatus,
                    statusChanged: false
                }
            });
        }

        // Check if estimate has expired
        const hasExpired = isEstimateExpired(estimate.valid_until);
        
        // Check if current status is a final status (Accepted, Rejected, Expired)
        if (['Accepted', 'Rejected', 'Expired'].includes(currentStatus)) {
            return res.status(400).json({
                message: 'Cannot change status of finalized estimate',
                errors: [{
                    field: 'status',
                    message: `Estimate is already ${currentStatus}. Status cannot be changed from final states (Accepted, Rejected, Expired).`
                }],
                estimate: {
                    id: estimate._id,
                    estimateReference: estimate.estimateReference,
                    currentStatus: currentStatus
                }
            });
        }

        // Business logic: Handle expired estimates
        // If estimate has expired, automatically set status to Expired (unless already finalized)
        if (hasExpired) {
            if (newStatus !== 'Expired') {
                // Auto-expire expired estimates
                estimate.status = 'Expired';
                await estimate.save();

                await estimate.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
                await estimate.populate('items.product_id', 'product_name product_code description pricing_inventory');

                return res.status(200).json({
                    message: 'Estimate has expired and status was automatically set to Expired',
                    estimate: {
                        id: estimate._id,
                        estimateReference: estimate.estimateReference,
                        status: estimate.status,
                        previousStatus: currentStatus,
                        statusChanged: true,
                        autoExpired: true,
                        validUntil: estimate.valid_until
                    }
                });
            }
            // If newStatus is 'Expired', allow the transition and continue
        }

        // Check if status transition is valid
        if (!isValidStatusTransition(currentStatus, newStatus)) {
            return res.status(400).json({
                message: 'Invalid status transition',
                errors: [{
                    field: 'status',
                    message: `Cannot change status from '${currentStatus}' to '${newStatus}'. Allowed transitions from '${currentStatus}': ${validStatusTransitions[currentStatus]?.join(', ') || 'none'}`
                }],
                estimate: {
                    id: estimate._id,
                    estimateReference: estimate.estimateReference,
                    currentStatus: currentStatus,
                    requestedStatus: newStatus
                }
            });
        }

        // Update status
        const previousStatus = estimate.status;
        estimate.status = newStatus;
        await estimate.save();

        // If status changed to "Accepted", create an invoice
        let createdInvoice = null;
        if (newStatus === 'Accepted' && previousStatus !== 'Accepted') {
            // Check if invoice already exists for this estimate
            const existingInvoice = await Invoice.findOne({ estimate_id: estimate._id });
            
            if (existingInvoice) {
                // Invoice already exists, return it in the response
                await existingInvoice.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
                await existingInvoice.populate('items.product_id', 'product_name product_code description pricing_inventory');
                createdInvoice = existingInvoice;
            } else {
                // Create new invoice from estimate
                // Calculate due date (default: 30 days from now, or use estimate valid_until if it's in the future)
                const now = new Date();
                const estimateValidUntil = new Date(estimate.valid_until);
                const defaultDueDate = new Date(now);
                defaultDueDate.setDate(defaultDueDate.getDate() + 30);
                
                // Use estimate valid_until if it's in the future, otherwise use default 30 days
                const dueDate = estimateValidUntil > now ? estimateValidUntil : defaultDueDate;

                const invoiceData = {
                    estimate_id: estimate._id,
                    customer_id: estimate.customer_id,
                    items: estimate.items.map(item => ({
                        product_id: item.product_id,
                        quantity: item.quantity,
                        unit_price: item.unit_price
                    })),
                    subtotal: estimate.subtotal,
                    tax_type: estimate.tax_type,
                    tax_value: estimate.tax_value,
                    discount_type: estimate.discount_type,
                    discount_value: estimate.discount_value,
                    total: estimate.total,
                    balance: estimate.total, // Initially balance equals total
                    status: 'Pending' as const,
                    paymentTerms: 'Net 30',
                    due_date: dueDate,
                    notes: estimate.notes || `Invoice created from estimate ${estimate.estimateReference}`,
                    sales_rep_id: estimate.sales_rep_id
                };

                const newInvoice = new Invoice(invoiceData);
                await newInvoice.save();

                // Populate references
                await newInvoice.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
                await newInvoice.populate('items.product_id', 'product_name product_code description pricing_inventory');
                
                createdInvoice = newInvoice;
            }
        }

        // Populate references for response
        await estimate.populate('customer_id', 'customerName customerEmail customerPhone customerBillingAddress');
        await estimate.populate('items.product_id', 'product_name product_code description pricing_inventory');

        const response: any = {
            message: 'Estimate status updated successfully',
            estimate: {
                id: estimate._id,
                estimateReference: estimate.estimateReference,
                status: estimate.status,
                previousStatus: previousStatus,
                statusChanged: true,
                validUntil: estimate.valid_until,
                isExpired: isEstimateExpired(estimate.valid_until)
            }
        };

        // Include invoice in response if created
        if (createdInvoice) {
            response.invoice = {
                id: createdInvoice._id,
                invoiceReference: createdInvoice.invoiceReference,
                estimate_id: createdInvoice.estimate_id,
                customer_id: createdInvoice.customer_id,
                items: createdInvoice.items,
                subtotal: createdInvoice.subtotal,
                tax_type: createdInvoice.tax_type,
                tax_value: createdInvoice.tax_value,
                discount_type: createdInvoice.discount_type,
                discount_value: createdInvoice.discount_value,
                total: createdInvoice.total,
                balance: createdInvoice.balance,
                status: createdInvoice.status,
                paymentTerms: createdInvoice.paymentTerms,
                due_date: createdInvoice.due_date,
                notes: createdInvoice.notes,
                sales_rep_id: createdInvoice.sales_rep_id,
                createdAt: createdInvoice.createdAt,
                updatedAt: createdInvoice.updatedAt
            };
            response.message = 'Estimate status updated successfully and invoice created';
        }

        return res.status(200).json(response);
    } catch (error) {
        if (error instanceof ValidationError) {
            return res.status(400).json({
                message: 'Validation failed',
                errors: error.errors
            });
        }
        
        const errorMessage = error instanceof Error ? error.message : String(error);
        return res.status(500).json({ 
            message: 'Error updating estimate status', 
            error: errorMessage
        });
    }
}
